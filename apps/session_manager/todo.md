# apps/session_manager/TODO.md

A3CP — session_manager TODO (module-scoped)

Scope: session boundary management and authoritative start/end events.
Status note (authoritative for this file): canonical migration completed (routes/service/repository/idgen/models), schemas fixed, baseline tests passing; behavioral invariants + expanded tests below are pending.

---

## Module invariants (locked)
- Schemas unchanged unless a hard blocker is hit.
- Append-only events everywhere (no in-place edits).
- Downstream request contract (non-session-manager endpoints): every downstream request includes `user_id` and `session_id` (and any module-specific fields).
- Session boundary event contract (session_manager outputs/logs): every emitted start/end event includes `user_id`, `session_id`, server-authoritative `timestamp`, and a new `record_id`.
- Log writing rule: only `schema_recorder` appends to `logs/users/<user_id>/sessions/<session_id>.jsonl` (session_manager may create the session directory but must not write the JSONL file).
- Storage rule (Sprint 1): do not persist raw video; persist only landmark-derived feature artifacts + `raw_features_ref` metadata (recorded later by `landmark_extractor`, not `session_manager`).
- Filesystem authority split (locked): session_manager MAY create session directories (mkdir only); it MUST NOT open, create, or append `*.jsonl` files. All JSONL writes are performed exclusively by `schema_recorder`.

---

## Slice-1 concurrency constraint (locked for Slice 1)
- Run single FastAPI worker / single replica for Slice 1.
- `session_manager` active-session state may be process-local memory.
- Deployment MUST enforce single-worker (no scale-out) until Option B is implemented.
- Option B (multi-worker/replica via shared store) is deferred and requires a dedicated migration.

---

## A) Completed

### Core behavior
- [x] `/sessions.start` returns `session_id`
- [x] `/sessions.end` closes session
- [x] Events appended via `schema_recorder`
- [x] Guardrail test: start → end emits 2 ordered events for the same `session_id`

### Canonical app architecture migration
- [x] Module migrated to canonical structure (routes/service/repository/idgen/models)
- [x] Schemas fixed
- [x] Baseline tests passing

---

## B) Remaining (this slice)

### 1) Event invariants enforced + tested (session_manager outputs & logs)
- [ ] Enforce/test invariants:
  - `source = "session_manager"`
  - `user_id` present
  - `session_id` present
  - `timestamp` present (UTC, ISO 8601, ms, "Z")
  - `record_id` present (UUIDv4)
  - `performer_id` policy:
    - required for human-originated start/end
    - allowed value `"system"` for system-generated boundaries

- [ ] Enforce/test invariant:
  - `session_id` emitted by `/sessions.end` MUST equal the `session_id` issued by `/sessions.start` for the same session
  - mismatched or regenerated `session_id` → reject (400)

- [ ] Enforce/test invariant:
  - `/sessions.start` and `/sessions.end` each emit a new, unique `record_id`
  - `record_id` MUST NOT be reused across session boundary events

- [ ] Enforce/test invariant:
  - `source` MUST be exactly `"session_manager"`
  - if the client supplies any other `source`, reject (400)
  - NOTE: confirm this behavior matches `SessionManagerStartInput`/`SessionManagerEndInput` `model_config.extra` (if `forbid`, this may already be rejected at validation)

- [ ] Enforce/test invariant:
  - `timestamp` is generated by `session_manager` (server-authoritative)
  - if the client supplies `timestamp`, reject (400)
  - NOTE: confirm this behavior matches `SessionManagerStartInput`/`SessionManagerEndInput` `model_config.extra` (if `forbid`, this may already be rejected at validation)

- [ ] Enforce/test invariant:
  - a user MAY NOT have more than one active session at the same time
  - `/sessions.start` while an active session exists → 409 Conflict (no auto-close in Slice 1)

- [ ] Enforce/test invariant:
  - session boundary outputs are Pydantic-validated (`SessionManagerStartOutput` / `SessionManagerEndOutput`)
  - invalid event payload MUST NOT be recorded to session JSONL (fail fast with 500/400 as appropriate)

- [ ] Enforce/test invariant (idempotency):
  - `/sessions.end`: repeated end for the same `session_id` → 409 Conflict

- [ ] Enforce/test invariant (system closure):
  - sessions MAY be closed by the system (e.g., timeout/cleanup) with `performer_id="system"`
  - system-closed end event MUST:
    - preserve the original `session_id`
    - generate a new unique `record_id`
    - use server-authoritative `timestamp`

- [ ] Enforce/test invariant (atomic recording):
  - Slice-1 atomicity: update in-memory session state only after a successful `schema_recorder` append
  - if `schema_recorder` append raises, the session remains in its prior state (no active session created / no session closed)
  - no code path appends a boundary event after a failed state transition

### 2) performer_id policy enforced at route ingress (session_manager)
- [ ] `/sessions.start`: if `performer_id != "system"`, require `performer_id` present (else 400)
- [ ] `/sessions.end`:   if `performer_id != "system"`, require `performer_id` present (else 400)
- [ ] allow `"system"` for system-generated boundaries (e.g., timeouts)

### 3) Guardrail tests for performer_id policy (session_manager)
- [ ] start/end with human-originated payload and missing `performer_id` → 400
- [ ] start/end with `performer_id="system"` → accepted
- [ ] recorded JSONL events reflect correct `performer_id`

### 4) Module test coverage (as listed in original plan)
- [ ] `apps/session_manager/tests/test_import_policy.py`
- [ ] `apps/session_manager/tests/test_session_jsonl_append.py`
  - [ ] verifies session_manager delegates event appends to `schema_recorder` (no direct JSONL writes)
  - [ ] allows session directory creation (`mkdir`) but forbids writing `*.jsonl`
- [ ] `apps/session_manager/tests/test_event_invariants.py`
  - invariants: `source/user_id/session_id/timestamp/record_id`
  - `performer_id` per canonical rule
- [ ] `apps/session_manager/tests/test_repository_append_event.py`
  - [ ] verifies session_manager repository does not write session JSONL directly (no `open()` / `Path.open()` on `*.jsonl`)
  - [ ] verifies the only allowed recording path is calling `schema_recorder` (service/repository boundary)
  - [ ] rejects direct file writes outside the allowed writer boundary

### 5) Domain error → HTTP mapping coverage
Slice-1 scope: these errors may originate from service/repository (not `domain.py` yet); the HTTP mapping behavior is locked.
- [ ] Add tests that domain errors map to HTTP correctly via routes
  - [ ] `SessionNotFound` → 404
  - [ ] `SessionUserMismatch` → 403
  - [ ] `SessionAlreadyClosed` → 400

---

## C) Deferred (explicitly later / optional)

### App-local config knobs
- [ ] `config.py`
  - [ ] `MODULE_SOURCE = "session_manager"`
  - [ ] `SESSION_ID_PREFIX = "sess_"`
  - [ ] `DEFAULT_TIMEOUT_SECONDS` (later)
  - [ ] `get_timeout_seconds()` (later)

### ID validation helper
- [ ] `idgen.py`
  - [x] `generate_session_id() -> str`
  - [ ] `is_valid_session_id(session_id: str) -> bool` (optional)

### Domain-only invariants/rules (pure)
- [ ] `domain.py`
  - [ ] `assert_can_end_session(session: Session, user_id: str) -> None`
  - [ ] `close_session(session: Session, end_time: datetime) -> Session`
  - [ ] Domain errors: `SessionNotFound`, `SessionUserMismatch`, `SessionAlreadyClosed`

### Repository surface (if/where needed beyond current implementation)
- [ ] `repository.py`
  - [ ] `create_active_session(session: Session) -> None`
  - [ ] `get_active_session(session_id: str) -> Session | None`
    - NOTE: returns only active sessions; closed sessions are not retrievable via this helper (demo scope)
  - [ ] `mark_session_closed(session_id: str, end_time: datetime) -> Session`
  - [ ] `append_event(cfg: RecorderConfig, user_id: str, session_id: str, message: BaseSchema) -> None`
  - [ ] `session_log_path(user_id: str, session_id: str) -> Path` (optional)

### Service surface (if/where needed beyond current implementation)
- [ ] `service.py`
  - [ ] `start_session(payload: SessionManagerStartInput) -> SessionManagerStartOutput`
  - [ ] `end_session(payload: SessionManagerEndInput) -> SessionManagerEndOutput`

### Routes inventory (kept here as reference)
- [ ] `routes/sessions.py` (FastAPI adapter only)
  - [ ] POST `/session_manager/sessions.start` → `SessionManagerStartOutput` (calls `service.start_session`)
  - [ ] POST `/session_manager/sessions.end`   → `SessionManagerEndOutput`   (calls `service.end_session`)
  - [ ] map domain errors to HTTP:
    - [ ] `SessionNotFound` → 404
    - [ ] `SessionUserMismatch` → 403
    - [ ] `SessionAlreadyClosed` → 400

---

## D) Domain model (current)
- [x] `models.py` (domain data, no FastAPI/IO)
  - [x] `SessionStatus = {"active", "closed"}`
  - [x] `Session(session_id, user_id, start_time, end_time?, status, is_training_data, session_notes?, training_intent_label?, performer_id?)`
