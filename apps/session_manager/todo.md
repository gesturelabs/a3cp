# apps/session_manager/TODO.md

A3CP — session_manager TODO (module-scoped)

Scope: session boundary management and authoritative start/end events.
Status note (authoritative for this file): canonical migration completed (routes/service/repository/idgen/models), schemas fixed, tests passing.

---

## Module invariants (locked)
- Schemas unchanged unless a hard blocker is hit.
- Append-only events everywhere (no in-place edits).
- Downstream contract: every downstream request includes `user_id`, `session_id`, `timestamp`, `record_id`.
- Log writing rule: only `recorded_schemas` appends to `logs/users/<user_id>/sessions/<session_id>.jsonl`.
- Storage rule (Sprint 1): do not persist raw video; persist only landmark-derived feature artifacts + `raw_features_ref` metadata (recorded later by landmark_extractor, not session_manager).

---

## A) Completed
### Core behavior
- [x] `/sessions.start` returns `session_id`
- [x] `/sessions.end` closes session
- [x] Events appended via `recorded_schemas`
- [x] Guardrail test: start → end emits 2 ordered events for the same `session_id`

### Canonical app architecture migration
- [x] Module migrated to canonical structure (routes/service/repository/idgen/models)
- [x] Schemas fixed
- [x] Tests passing

---

## B) Remaining (this slice)
### 1) Event invariants enforced + tested (session_manager outputs & logs)
- [ ] Enforce/test invariants:
  - `source = "session_manager"`
  - `user_id` present
  - `session_id` present
  - `timestamp` present (UTC, ISO 8601, ms, "Z")
  - `record_id` present (UUIDv4)
  - `performer_id` policy:
    - required for human-originated start/end
    - allowed value `"system"` for system-generated boundaries
  - [ ] Enforce/test invariant:
  - `session_id` emitted by `/sessions.end` MUST equal the `session_id` issued by `/sessions.start` for the same session
  - mismatched or regenerated `session_id` → reject (400)

- [ ] Enforce/test invariant:
  - `/sessions.start` and `/sessions.end` each emit a **new, unique `record_id`**
  - `record_id` MUST NOT be reused across session boundary events

- [ ] Enforce/test invariant:
  - `source` MUST be exactly `"session_manager"`
  - client-supplied `source` values are ignored or rejected

- [ ] Enforce/test invariant:
  - `timestamp` is generated by `session_manager` (server-authoritative)
  - client-supplied `timestamp` values are ignored or rejected

- [ ] Enforce/test invariant:
  - a user MAY NOT have more than one active session at the same time
  - `/sessions.start` while an active session exists → reject (400) or auto-close (choose one)

- [ ] Enforce/test invariant:
  - session boundary outputs are Pydantic-validated (`SessionManagerStartOutput` / `SessionManagerEndOutput`)
  - invalid event payload MUST NOT be recorded to session JSONL (fail fast with 500/400 as appropriate)
- [ ] Enforce/test invariant (idempotency):
  - `/sessions.start` MUST NOT record duplicate start events for the same `session_id`
    - repeated start for same `session_id` → reject **409 Conflict**
  - `/sessions.end` MUST NOT record duplicate end events for the same `session_id`
    - rrepeated end for same `session_id` → reject **409 Conflict**

- [ ] Enforce/test invariant (system closure):
  - sessions MAY be closed by the system (e.g., timeout/cleanup) with `performer_id="system"`
  - system-closed end event MUST:
    - preserve the original `session_id`
    - generate a new unique `record_id`
    - use server-authoritative `timestamp`


- [ ] Enforce/test invariant (atomic recording):
  - session state change (start/end) and JSONL event append MUST be atomic
  - on append failure, session MUST NOT transition state
  - on state transition failure, JSONL event MUST NOT be appended

### 2) performer_id policy enforced at route ingress (session_manager)
- [ ] `/sessions.start`: if `performer_id != "system"`, require `performer_id` present (else 400)
- [ ] `/sessions.end`:   if `performer_id != "system"`, require `performer_id` present (else 400)
- [ ] allow `"system"` for system-generated boundaries (e.g., timeouts)

### 3) Guardrail tests for performer_id policy (session_manager)
- [ ] start/end with human-originated payload and missing `performer_id` → 400
- [ ] start/end with `performer_id="system"` → accepted
- [ ] recorded JSONL events reflect correct `performer_id`

### 4) Module test coverage (as listed in original plan)
- [ ] `apps/session_manager/tests/test_import_policy.py`
- [ ] `apps/session_manager/tests/test_session_jsonl_append.py`
- [ ] `apps/session_manager/tests/test_event_invariants.py`
  - invariants: `source/user_id/session_id/timestamp/record_id`
  - performer_id per canonical rule
- [ ] `apps/session_manager/tests/test_repository_append_event.py`
  - [ ] verifies `append_event(...)` is the *only* writer to session JSONL
  - [ ] rejects direct file writes outside repository boundary



#### 5) Domain error → HTTP mapping coverage
- [ ] Add tests that domain errors map to HTTP correctly (404/400) via routes
  - [ ] SessionNotFound → 404
  - [ ] SessionUserMismatch → 400 (or 403 if you later choose)
  - [ ] SessionAlreadyClosed → 400
- [ ] routes map domain errors correctly:
  - [ ] SessionNotFound → 404
  - [ ] SessionUserMismatch → 400
  - [ ] SessionAlreadyClosed → 400

---

## C) Deferred (explicitly later / optional)
### App-local config knobs
- [ ] `config.py`
  - [ ] `MODULE_SOURCE = "session_manager"`
  - [ ] `SESSION_ID_PREFIX = "sess_"`
  - [ ] `DEFAULT_TIMEOUT_SECONDS` (later)
  - [ ] `get_timeout_seconds()` (later)

### ID validation helper
- [ ] `idgen.py`
  - [x] `generate_session_id() -> str`
  - [ ] `is_valid_session_id(session_id: str) -> bool` (optional)

### Domain-only invariants/rules (pure)
- [ ] `domain.py`
  - [ ] `assert_can_end_session(session: Session, user_id: str) -> None`
  - [ ] `close_session(session: Session, end_time: datetime) -> Session`
  - [ ] Domain errors: `SessionNotFound`, `SessionUserMismatch`, `SessionAlreadyClosed`


### Repository surface (if/where needed beyond current implementation)
- [ ] `repository.py`
  - [ ] `create_active_session(session: Session) -> None`
  - [ ] get_active_session(session_id: str) -> Session | None
    - NOTE: returns only active sessions; closed sessions are not retrievable via this helper (demo scope)

  - [ ] `mark_session_closed(session_id: str, end_time: datetime) -> Session`
  - [ ] `append_event(cfg: RecorderConfig, user_id: str, session_id: str, message: BaseSchema) -> None`
  - [ ] `session_log_path(user_id: str, session_id: str) -> Path` (optional)

### Service surface (if/where needed beyond current implementation)
- [ ] `service.py`
  - [ ] `start_session(payload: SessionManagerStartInput) -> SessionManagerStartOutput`
  - [ ] `end_session(payload: SessionManagerEndInput) -> SessionManagerEndOutput`

### Routes inventory (kept here as reference)
- [ ] `routes/sessions.py` (FastAPI adapter only)
  - [ ] POST `/session_manager/sessions.start` → `SessionManagerStartOutput` (calls `service.start_session`)
  - [ ] POST `/session_manager/sessions.end`   → `SessionManagerEndOutput`   (calls `service.end_session`)
 - [ ] map domain errors to HTTP:
  - [ ] SessionNotFound → 404
  - [ ] SessionUserMismatch → 400
  - [ ] SessionAlreadyClosed → 400
---

## D) Domain model (current)
- [x] `models.py` (domain data, no FastAPI/IO)
  - [x] `SessionStatus = {"active", "closed"}`
  - [x] `Session(session_id, user_id, start_time, end_time?, status, is_training_data, session_notes?, training_intent_label?, performer_id?)`

---
